<html>

<head>
<title>Learning WebGL</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script id="per-fragment-lighting-fs" type="x-shader/x-fragment">
    precision mediump float;

    // Color Elements
    varying vec4 vColor;
    
    //Texture Elements
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;
    
    //Lighting Elements
    //varying vec3 vLightWeighting;
    
    /// Common with Vertex Lighting Vertex Shader ///
    // Lighting Elements
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;
    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;
    uniform vec3 uEmissiveColor;
    uniform bool uUseLighting;
    uniform bool uUseDirectionalLighting;
    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingColor;

    /// New ///
    // Texture Elements
    uniform bool uUseTextures;


    void main(void) {
        vec3 ambientLightWeighting = uAmbientColor;
        
        vec3 vLightWeighting;
        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else if (uUseDirectionalLighting) {
            //transformedNormal = uNMatrix * aVertexNormal;
            float directionalLightWeighting = max(dot(vTransformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        } else { // Point Lighting
            vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);
            
            float directionalLightWeighting = max(dot(normalize(vTransformedNormal), lightDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }

        vec4 fragmentColor;
        if (uUseTextures) {
            fragmentColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        } else {
            fragmentColor = vec4(1.0, 1.0, 1.0, 1.0);
        }
        gl_FragColor = vec4(fragmentColor.rgb * vLightWeighting + uEmissiveColor.rgb, fragmentColor.a);
    }
</script>
    
<script id="per-vertex-lighting-fs" type="x-shader/x-fragment">
    precision mediump float;

    // Color Elements
    varying vec4 vColor;
    
    // Texture Elements
    varying vec2 vTextureCoord;
    uniform sampler2D uSampler;    
    
    // Lighting Elements
    varying vec3 vLightWeighting;
    

    void main(void) {
        vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
          gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
    }
</script>

<script id="per-vertex-lighting-vs" type="x-shader/x-vertex">
    // Basic Elements (Matrices and Vertices)
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    attribute vec3 aVertexPosition;
    varying vec4 vPosition;

    // Normals
    uniform mat3 uNMatrix;
    attribute vec3 aVertexNormal;

    // Color Elements
    attribute vec4 aVertexColor;    
    //varying vec4 vColor;

    // Texture Elements
    attribute vec2 aTextureCoord;
    varying vec2 vTextureCoord;
    uniform bool uUseTextures;

    // Lighting Elements
    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;
    uniform bool uUseLighting;
    uniform bool uUseDirectionalLighting;
    varying vec3 vLightWeighting;
    uniform vec3 uPointLightingLocation;
    uniform vec3 uPointLightingColor;
    varying vec3 transformedNormal;
    
    uniform vec4 uPickingColor; // NOT USED

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;

        if (!uUseLighting) {
            vLightWeighting = vec3(1.0, 1.0, 1.0);
        } else if (uUseDirectionalLighting) {
            transformedNormal = uNMatrix * aVertexNormal;
            float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        } else {
            vec3 lightDirection = normalize(uPointLightingLocation - vPosition.xyz);

            transformedNormal = uNMatrix * aVertexNormal;
            float directionalLightWeighting = max(dot(transformedNormal, lightDirection), 0.0);
            vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        }
    }
</script>

<script id="per-fragment-lighting-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    varying vec2 vTextureCoord;
    varying vec3 vTransformedNormal;
    varying vec4 vPosition;

    uniform vec4 uPickingColor; // NOT USED

    void main(void) {
        vPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_Position = uPMatrix * vPosition;
        vTextureCoord = aTextureCoord;
        vTransformedNormal = uNMatrix * aVertexNormal;
    }
</script>
<script id="picking-shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec4 vColor;
    void main(void) {
	    
        gl_FragColor = vColor;
    }
</script>

<script id="picking-shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec4 aVertexColor;
    attribute vec3 aVertexNormal;
    attribute vec2 aTextureCoord;
    
    uniform vec4 uPickingColor;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec4 vColor;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = uPickingColor;
    }
</script>
    
    
<script type="text/javascript">

    var gl;
    function initGL(canvas) {
        try {
            gl = canvas.getContext("experimental-webgl");
            gl.viewportWidth = canvas.width;
            gl.viewportHeight = canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }


    function getShader(gl, id) {
        var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == Node.TEXT_NODE) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }

    function createProgram(fragmentShaderID, vertexShaderID) {
        var fragmentShader = getShader(gl, fragmentShaderID);
        var vertexShader = getShader(gl, vertexShaderID);

        var program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

         program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
         gl.enableVertexAttribArray(program.vertexPositionAttribute);

        program.vertexNormalAttribute = gl.getAttribLocation(program, "aVertexNormal");
        gl.enableVertexAttribArray(program.vertexNormalAttribute);

        program.textureCoordAttribute = gl.getAttribLocation(program, "aTextureCoord");
        gl.enableVertexAttribArray(program.textureCoordAttribute);

        program.pMatrixUniform = gl.getUniformLocation(program, "uPMatrix");
        program.mvMatrixUniform = gl.getUniformLocation(program, "uMVMatrix");
        program.nMatrixUniform = gl.getUniformLocation(program, "uNMatrix");
        program.samplerUniform = gl.getUniformLocation(program, "uSampler");
        program.useLightingUniform = gl.getUniformLocation(program, "uUseLighting");
        program.useTexturesUniform = gl.getUniformLocation(program, "uUseTextures");
        program.useDirectionalLightingUniform = gl.getUniformLocation(program, "uUseDirectionalLighting");
        program.ambientColorUniform = gl.getUniformLocation(program, "uAmbientColor");
        program.emissiveColorUniform = gl.getUniformLocation(program, "uEmissiveColor");
        program.pickingColorUniform = gl.getUniformLocation(program, "uPickingColor");
        program.lightingDirectionUniform = gl.getUniformLocation(program, "uLightingDirection");
        program.directionalColorUniform = gl.getUniformLocation(program, "uDirectionalColor");
        program.pointLightingLocationUniform = gl.getUniformLocation(program, "uPointLightingLocation");
        
        return program;
    }

    var currentProgram;
    var perVertexProgram;
    var perFragmentProgram;
    var pickingProgram;

    function initShaders() {
        perVertexProgram = createProgram("per-vertex-lighting-fs", "per-vertex-lighting-vs");
        perFragmentProgram = createProgram("per-fragment-lighting-fs", "per-fragment-lighting-vs");
        pickingProgram = createProgram("picking-shader-fs", "picking-shader-vs");
    }
    
    
    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

   function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
  }

  function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
      throw "Invalid popMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
  }   
    
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(currentProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(currentProgram.mvMatrixUniform, false, mvMatrix);

        var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(currentProgram.nMatrixUniform, false, normalMatrix);
    }

    function generateSphere(radius)
    {
        var latitudeBands = 30;
        var longitudeBands = 30;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(x);
                normalData.push(y);
                normalData.push(z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                
                indexData.push(first);
                indexData.push(second);
                indexData.push(first + 1);

                indexData.push(second);
                indexData.push(second + 1);
                indexData.push(first + 1);
            }
        }
        return [vertexPositionData, textureCoordData, normalData, indexData];
    }
    
    function generateInvertedSphere(radius)
    {
        var latitudeBands = 30;
        var longitudeBands = 30;

        var vertexPositionData = [];
        var normalData = [];
        var textureCoordData = [];
        for (var latNumber=0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber=0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1 - (longNumber / longitudeBands);
                var v = 1 - (latNumber / latitudeBands);

                normalData.push(-x);
                normalData.push(-y);
                normalData.push(-z);
                textureCoordData.push(u);
                textureCoordData.push(v);
                vertexPositionData.push(radius * x);
                vertexPositionData.push(radius * y);
                vertexPositionData.push(radius * z);
            }
        }

        var indexData = [];
        for (var latNumber=0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber=0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                
                indexData.push(first + 1);
                indexData.push(second);
                indexData.push(first);

                indexData.push(first + 1);
                indexData.push(second + 1);
                indexData.push(second);
            }
        }
        return [vertexPositionData, textureCoordData, normalData, indexData];
    }

    // Flyweight Pattern - establish examples of each
    //    buffer, to be reused later
    var triangleVertexPositionBuffer;
    var triangleVertexColorBuffer;
    var squareVertexPositionBuffer;
    var squareVertexColorBuffer;
    var pyramidVertexPositionBuffer;
    var pyramidVertexColorBuffer;
    var cubeVertexPositionBuffer;
    var cubeVertexColorBuffer;
    var cubeVertexIndexBuffer;
    var skydomeVertexPositionBuffer;
    var skydomeVertexNormalBuffer;
    var skydomeVertexTextureCoordBuffer;
    var skydomeVertexIndexBuffer;
    var sunVertexPositionBuffer;
    var sunVertexNormalBuffer;
    var sunVertexTextureCoordBuffer;
    var sunVertexIndexBuffer;

    function initBuffers() {
        // 2D Triangle
        triangleVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        var vertices = [
             0.0,  1.0,  0.0,
            -1.0, -1.0,  0.0,
             1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 3;

    triangleVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
    var colors = [
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    triangleVertexColorBuffer.itemSize = 4;
    triangleVertexColorBuffer.numItems = 3;   
        
        // 2D Square
        squareVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        vertices = [
             1.0,  1.0,  0.0,
            -1.0,  1.0,  0.0,
             1.0, -1.0,  0.0,
            -1.0, -1.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        squareVertexPositionBuffer.itemSize = 3;
        squareVertexPositionBuffer.numItems = 4;
        
    squareVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexColorBuffer);
    colors = []
    for (var i=0; i < 4; i++) {
      colors = colors.concat([0.5, 0.5, 1.0, 1.0]);
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    squareVertexColorBuffer.itemSize = 4;
    squareVertexColorBuffer.numItems = 4;
        
    squareVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
        var textureCoords = [
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            1.0, 1.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
        squareVertexTextureCoordBuffer.itemSize = 2;
        squareVertexTextureCoordBuffer.numItems = 4; 
        
        // 3D Pyramid
            pyramidVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexPositionBuffer);
    var vertices = [
        // Front face
         0.0,  1.0,  0.0,
        -1.0, -1.0,  1.0,
         1.0, -1.0,  1.0,
        // Right face
         0.0,  1.0,  0.0,
         1.0, -1.0,  1.0,
         1.0, -1.0, -1.0,
        // Back face
         0.0,  1.0,  0.0,
         1.0, -1.0, -1.0,
        -1.0, -1.0, -1.0,
        // Left face
         0.0,  1.0,  0.0,
        -1.0, -1.0, -1.0,
        -1.0, -1.0,  1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    pyramidVertexPositionBuffer.itemSize = 3;
    pyramidVertexPositionBuffer.numItems = 12;
 
    pyramidVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pyramidVertexColorBuffer);
    var colors = [
        // Front face
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        // Right face
        1.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        // Back face
        1.0, 0.0, 0.0, 1.0,
        0.0, 1.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        // Left face
        1.0, 0.0, 0.0, 1.0,
        0.0, 0.0, 1.0, 1.0,
        0.0, 1.0, 0.0, 1.0
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    pyramidVertexColorBuffer.itemSize = 4;
    pyramidVertexColorBuffer.numItems = 12; 
       
        
     // 3D Cube
    cubeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
    vertices = [
      // Front face
      -1.0, -1.0,  1.0,
       1.0, -1.0,  1.0,
       1.0,  1.0,  1.0,
      -1.0,  1.0,  1.0,

      // Back face
      -1.0, -1.0, -1.0,
      -1.0,  1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0, -1.0, -1.0,

      // Top face
      -1.0,  1.0, -1.0,
      -1.0,  1.0,  1.0,
       1.0,  1.0,  1.0,
       1.0,  1.0, -1.0,

      // Bottom face
      -1.0, -1.0, -1.0,
       1.0, -1.0, -1.0,
       1.0, -1.0,  1.0,
      -1.0, -1.0,  1.0,

      // Right face
       1.0, -1.0, -1.0,
       1.0,  1.0, -1.0,
       1.0,  1.0,  1.0,
       1.0, -1.0,  1.0,

      // Left face
      -1.0, -1.0, -1.0,
      -1.0, -1.0,  1.0,
      -1.0,  1.0,  1.0,
      -1.0,  1.0, -1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    cubeVertexPositionBuffer.itemSize = 3;
    cubeVertexPositionBuffer.numItems = 24;
        
    cubeVertexColorBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
    colors = [
      [1.0, 0.0, 0.0, 1.0],     // Front face
      [1.0, 1.0, 0.0, 1.0],     // Back face
      [0.0, 1.0, 0.0, 1.0],     // Top face
      [1.0, 0.5, 0.5, 1.0],     // Bottom face
      [1.0, 0.0, 1.0, 1.0],     // Right face
      [0.0, 0.0, 1.0, 1.0],     // Left face
    ];
    var unpackedColors = [];
    for (var i in colors) {
      var color = colors[i];
      for (var j=0; j < 4; j++) {
        unpackedColors = unpackedColors.concat(color);
      }
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
    cubeVertexColorBuffer.itemSize = 4;
    cubeVertexColorBuffer.numItems = 24;
        
     cubeVertexIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
    var cubeVertexIndices = [
      0, 1, 2,      0, 2, 3,    // Front face
      4, 5, 6,      4, 6, 7,    // Back face
      8, 9, 10,     8, 10, 11,  // Top face
      12, 13, 14,   12, 14, 15, // Bottom face
      16, 17, 18,   16, 18, 19, // Right face
      20, 21, 22,   20, 22, 23  // Left face
    ]
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
    cubeVertexIndexBuffer.itemSize = 1;
    cubeVertexIndexBuffer.numItems = 36;

    cubeVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexTextureCoordBuffer);
    var textureCoords = [
      // Front face
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,

      // Back face
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,

      // Top face
      0.0, 1.0,
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,

      // Bottom face
      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,
      1.0, 0.0,

      // Right face
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
      0.0, 0.0,

      // Left face
      0.0, 0.0,
      1.0, 0.0,
      1.0, 1.0,
      0.0, 1.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
    cubeVertexTextureCoordBuffer.itemSize = 2;
    cubeVertexTextureCoordBuffer.numItems = 24;
        
           cubeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
    var vertexNormals = [
      // Front face
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,
       0.0,  0.0,  1.0,

      // Back face
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,
       0.0,  0.0, -1.0,

      // Top face
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,
       0.0,  1.0,  0.0,

      // Bottom face
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,
       0.0, -1.0,  0.0,

      // Right face
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,
       1.0,  0.0,  0.0,

      // Left face
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
      -1.0,  0.0,  0.0,
    ];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
    cubeVertexNormalBuffer.itemSize = 3;
    cubeVertexNormalBuffer.numItems = 24;
        
        // generateSphere returns [vertexPositionData, textureCoordData, normalData, indexData];
        // 3D Sphere
        var skydomeArrays = generateInvertedSphere(40);
        skydomeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, skydomeVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(skydomeArrays[2]), gl.STATIC_DRAW);
        skydomeVertexNormalBuffer.itemSize = 3;
        skydomeVertexNormalBuffer.numItems = skydomeArrays[2].length / 3;

        skydomeVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, skydomeVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(skydomeArrays[1]), gl.STATIC_DRAW);
        skydomeVertexTextureCoordBuffer.itemSize = 2;
        skydomeVertexTextureCoordBuffer.numItems = skydomeArrays[1].length / 2;

        skydomeVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, skydomeVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(skydomeArrays[0]), gl.STATIC_DRAW);
        skydomeVertexPositionBuffer.itemSize = 3;
        skydomeVertexPositionBuffer.numItems = skydomeArrays[0].length / 3;

        skydomeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, skydomeVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(skydomeArrays[3]), gl.STATIC_DRAW);
        skydomeVertexIndexBuffer.itemSize = 1;
        skydomeVertexIndexBuffer.numItems = skydomeArrays[3].length;
        
        var sunArrays = generateSphere(1);
        sunVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexNormalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sunArrays[2]), gl.STATIC_DRAW);
        sunVertexNormalBuffer.itemSize = 3;
        sunVertexNormalBuffer.numItems = sunArrays[2].length / 3;

        sunVertexTextureCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexTextureCoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sunArrays[1]), gl.STATIC_DRAW);
        sunVertexTextureCoordBuffer.itemSize = 2;
        sunVertexTextureCoordBuffer.numItems = sunArrays[1].length / 2;

        sunVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, sunVertexPositionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(sunArrays[0]), gl.STATIC_DRAW);
        sunVertexPositionBuffer.itemSize = 3;
        sunVertexPositionBuffer.numItems = sunArrays[0].length / 3;

        sunVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sunVertexIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(sunArrays[3]), gl.STATIC_DRAW);
        sunVertexIndexBuffer.itemSize = 1;
        sunVertexIndexBuffer.numItems = sunArrays[3].length;
    }
    
    
    var rttFramebuffer;
    var rttTexture;
    function initTextureFramebuffer() {
        rttFramebuffer = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
        rttFramebuffer.width = 512;
        rttFramebuffer.height = 512;

        rttTexture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, rttTexture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
        //gl.generateMipmap(gl.TEXTURE_2D);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, rttFramebuffer.width, rttFramebuffer.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        var renderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, rttFramebuffer.width, rttFramebuffer.height);

        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, rttTexture, 0);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

        gl.bindTexture(gl.TEXTURE_2D, null);
        gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
    
    
    var neheTexture;
    var crateTexture;
    var starTexture;
    var greenTexture;
    var blueTexture;
    var whiteTexture;
    var seaTexture;

    function initTexture() {
            neheTexture = loadTexture(gl, "coderfaire.gif");
            crateTexture = loadTexture(gl, "crate.gif");
            greenTexture = loadTexture(gl, "2F893B-1.png");
            blueTexture = loadTexture(gl, "1212FF-1.png");
            whiteTexture = loadTexture(gl, "FFFFFF-1.0.png");
            starTexture = loadTexture(gl, "star.gif");
            seaTexture = loadTexture(gl, "0027-sea-water-texture-seamless.jpg");
    }

function loadTexture(gl, url) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Because images have to be download over the internet
  // they might take a moment until they are ready.
  // Until then put a single pixel in the texture so we can
  // use it immediately. When the image has finished downloading
  // we'll update the texture with the contents of the image.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);  // opaque blue
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  srcFormat, srcType, image);

    // WebGL1 has different requirements for power of 2 images
    // vs non power of 2 images so check if the image is a
    // power of 2 in both dimensions.
    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
       // Yes, it's a power of 2. Generate mips.
       gl.generateMipmap(gl.TEXTURE_2D);
    } else {
       // No, it's not a power of 2. Turn of mips and set
       // wrapping to clamp to edge
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
  };
  image.src = url;
  texture.image = image

  return texture;
}

function isPowerOf2(value) {
  return (value & (value - 1)) == 0;
}
    
      function Terrain(detail) {
        this.size = Math.pow(2, detail) + 1;
        this.max = this.size - 1;
        this.map = new Float32Array(this.size * this.size);
      }
    
      Terrain.prototype.get = function(x, y) {
        if (x < 0 || x > this.max || y < 0 || y > this.max) return -1;
        return this.map[x + this.size * y];
      };
      Terrain.prototype.set = function(x, y, val) {
        this.map[x + this.size * y] = val;
      };
      Terrain.prototype.generate = function(roughness) {
        var self = this;
        this.set(0, 0, self.max);
        this.set(this.max, 0, self.max / 2);
        this.set(this.max, this.max, 0);
        this.set(0, this.max, self.max / 2);
        divide(this.max);
        function divide(size) {
          var x, y, half = size / 2;
          var scale = roughness * size;
          if (half < 1) return;
          for (y = half; y < self.max; y += size) {
            for (x = half; x < self.max; x += size) {
              square(x, y, half, Math.random() * scale * 2 - scale);
            }
          }
          for (y = 0; y <= self.max; y += half) {
            for (x = (y + half) % size; x <= self.max; x += size) {
              diamond(x, y, half, Math.random() * scale * 2 - scale);
            }
          }
          divide(size / 2);
        }
        function average(values) {
          var valid = values.filter(function(val) { return val !== -1; });
          var total = valid.reduce(function(sum, val) { return sum + val; }, 0);
          return total / valid.length;
        }
        function square(x, y, size, offset) {
          var ave = average([
            self.get(x - size, y - size),   // upper left
            self.get(x + size, y - size),   // upper right
            self.get(x + size, y + size),   // lower right
            self.get(x - size, y + size)    // lower left
          ]);
          self.set(x, y, ave + offset);
        }
        function diamond(x, y, size, offset) {
          var ave = average([
            self.get(x, y - size),      // top
            self.get(x + size, y),      // right
            self.get(x, y + size),      // bottom
            self.get(x - size, y)       // left
          ]);
          self.set(x, y, ave + offset);
        }
      };    

  function loadWorld() {
    var request = new XMLHttpRequest();
    request.open("GET", "world.txt");
    request.onreadystatechange = function() {
      if (request.readyState == 4) {
        handleLoadedWorld(request.responseText);
      }
    }
    request.send();
  }
    
  var worldVertexPositionBuffer = null;
  var worldVertexTextureCoordBuffer = null;
  function handleLoadedWorld(data) {
    var lines = data.split("\n");
    var vertexCount = 0;
    var vertexPositions = [];
    var vertexTextureCoords = [];
    for (var i in lines) {
      var vals = lines[i].replace(/^\s+/, "").split(/\s+/);
      if (vals.length == 5 && vals[0] != "//") {
        // It is a line describing a vertex; get X, Y and Z first
        vertexPositions.push(parseFloat(vals[0]));
        vertexPositions.push(parseFloat(vals[1]));
        vertexPositions.push(parseFloat(vals[2]));

        // And then the texture coords
        vertexTextureCoords.push(parseFloat(vals[3]));
        vertexTextureCoords.push(parseFloat(vals[4]));

        vertexCount += 1;
      }
    }
    worldVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions), gl.STATIC_DRAW);
    worldVertexPositionBuffer.itemSize = 3;
    worldVertexPositionBuffer.numItems = vertexCount;

    worldVertexTextureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexTextureCoords), gl.STATIC_DRAW);
    worldVertexTextureCoordBuffer.itemSize = 2;
    worldVertexTextureCoordBuffer.numItems = vertexCount;
  }
    
/*
    function initTexture() {
      neheTexture = gl.createTexture();
      neheTexture.image = new Image();
      neheTexture.image.onload = function() {
        handleLoadedTexture(neheTexture)
      }

      //neheTexture.image.crossOrigin = null; // could also be "use-credentials", "anonymous" or undefined (which does not ask)
      neheTexture.image.src = "nehe.gif";
    }
    
  function handleLoadedTexture(texture) {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        
    gl.bindTexture(gl.TEXTURE_2D, null);
  } 
  */
    
    DrawingObject.prototype.draw = function(type) {


		setMatrixUniforms();
		
        // Draw 
        this.drawObject(type)
	}
    
	DrawingObject.prototype.drawObject  = function(type) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexPositionBuffer);
          gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, this.vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);
    gl.uniform1i(currentProgram.samplerUniform, 0);
        
  //  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexColorBuffer);
  //  gl.vertexAttribPointer(currentProgram.vertexColorAttribute, this.vertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);        

		  if (type == "square")
		  {
             gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
		  }
          else if (type == "cube")
          {    
              if (this.vertexNormalBuffer != null) {
             gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexNormalBuffer); 
             gl.vertexAttribPointer(currentProgram.vertexNormalAttribute, this.vertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
              }

              if (this.vertexTextureCoordBuffer != null) { 
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexTextureCoordBuffer);
        gl.vertexAttribPointer(currentProgram.textureCoordAttribute, this.vertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);
              }

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.uniform1i(currentProgram.samplerUniform, 0);
        gl.uniform1i(currentProgram.useLightingUniform, lighting);
        gl.uniform1i(currentProgram.useDirectionalLightingUniform, !pointLighting);
        gl.uniform1i(currentProgram.useTexturesUniform, textures);
        if (lighting) {
            gl.uniform3f(
                currentProgram.emissiveColorUniform,
                this.emissiveColor[0],
                this.emissiveColor[1],
                this.emissiveColor[2]
            );
            gl.uniform3f(
                currentProgram.ambientColorUniform,
                ambientR,
                ambientG,
                ambientB
            );
            // Use the location of the sun (Object #2) for the point lighting location
            gl.uniform3f(
                currentProgram.pointLightingLocationUniform,
        drawingObjects[2].x,
        drawingObjects[2].y,
        drawingObjects[2].z );
            
            gl.uniform3f(
                currentProgram.pointLightingColorUniform,
        pointR,
        pointG,
        pointB );

            var lightingDirection = [lightDirectionX,
                                     lightDirectionY,
                                     lightDirectionZ
            ];
            var adjustedLD = vec3.create();
            vec3.normalize(lightingDirection, adjustedLD);
            vec3.scale(adjustedLD, -1);
            gl.uniform3fv(currentProgram.lightingDirectionUniform, adjustedLD);

            gl.uniform3f(
                currentProgram.directionalColorUniform,
                directionalR, directionalG, directionalB
            );
        }
             

              if (this.vertexIndexBuffer != null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vertexIndexBuffer);
        setMatrixUniforms();
        gl.drawElements(gl.TRIANGLES, this.vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
              } else {
        // Draw the star in its main color
        gl.uniform3f(currentProgram.colorUniform, 1.0, 1.0, 1.0);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, starTexture);
        gl.uniform1i(currentProgram.samplerUniform, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexTextureCoordBuffer);
        gl.vertexAttribPointer(currentProgram.textureCoordAttribute, squareVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
        gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, squareVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

        setMatrixUniforms();
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, squareVertexPositionBuffer.numItems);
              }
                      
          }
		  else
		  {
		     gl.drawArrays(gl.TRIANGLES, 0, this.vertexPositionBuffer.numItems);
		  }
	}
    
    
    
    function drawScene() {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        if (perFragmentLighting) {
            currentProgram = perFragmentProgram;
        } else {
            currentProgram = perVertexProgram;
        }
        gl.useProgram(currentProgram);
        
        mat4.identity(mvMatrix);

        // Camera (Perspective) - Attached to Object # 0
        mat4.rotate(mvMatrix, drawingObjects[0].rx, [1, 0, 0]);
        mat4.rotate(mvMatrix, drawingObjects[0].ry, [0, 1, 0]);
        mat4.rotate(mvMatrix, drawingObjects[0].rz, [0, 0, 1]);
        mat4.translate(mvMatrix, [drawingObjects[0].x, drawingObjects[0].y, drawingObjects[0].z]);
        
        
        // Draw World Wireframe (if there is one)
        /*
        if (worldVertexTextureCoordBuffer != null && worldVertexPositionBuffer != null) {
           gl.activeTexture(gl.TEXTURE0);
           gl.bindTexture(gl.TEXTURE_2D, mudTexture);
           gl.uniform1i(currentPrograms.samplerUniform, 0);

           gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexTextureCoordBuffer);
           gl.vertexAttribPointer(currentProgram.textureCoordAttribute, worldVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

           gl.bindBuffer(gl.ARRAY_BUFFER, worldVertexPositionBuffer);
           gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, worldVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

           setMatrixUniforms();
           gl.drawArrays(gl.TRIANGLES, 0, worldVertexPositionBuffer.numItems);
           
        }
        */

        // Don't draw object #0 (the camera)
        for (var i = 1, len = drawingObjects.length; i < len; i++) {
           mvPushMatrix();
            
           mat4.translate(mvMatrix, [drawingObjects[i].x, drawingObjects[i].y, drawingObjects[i].z]);
            
           mvPushMatrix();
            
           mat4.rotate(mvMatrix, drawingObjects[i].rx, [1,0,0]);
           mat4.rotate(mvMatrix, drawingObjects[i].ry, [0,1,0]);
           mat4.rotate(mvMatrix, drawingObjects[i].rz, [0,0,1]);
              
            
            
		   setMatrixUniforms();
	//	   if (i == 0) {
    //          drawingObjects[i].draw("tri");	         		  
	//	   }
	//	   else
	//	   {
		      //drawingObjects[i].draw("square");
              drawingObjects[i].draw("cube"); 
	//	   }
		   
            mvPopMatrix();
            mvPopMatrix();
		}
        

        gl.uniform1i(currentProgram.samplerUniform, 0);
    }

	function DrawingObject(texture, objVertexBuffer, objVertexColorBuffer, objVertexNormalBuffer, objVertexIndexBuffer, objVertexTextureCoordBuffer, objX, objY, objZ, rotX, rotY, rotZ) {
       this.texture = texture;
	   this.vertexPositionBuffer = objVertexBuffer;
       this.vertexColorBuffer = objVertexColorBuffer;
       this.vertexNormalBuffer = objVertexNormalBuffer;
       this.vertexIndexBuffer = objVertexIndexBuffer;
       this.vertexTextureCoordBuffer = objVertexTextureCoordBuffer;
	   this.x = objX;
	   this.y = objY;
	   this.z = objZ;
       this.rx = rotX;
       this.ry = rotY;
       this.rz = rotZ;
       this.v = vec3.create() // linear velocity
       this.v[0] = 0; this.v[1] = 0; this.v[2] = 0;
       this.w = vec3.create() // angular velocity 
       this.w[0] = 0; this.w[1] = 0; this.w[2] = 0;
       this.emissiveColor = vec3.create();
       this.emissiveColor[0] = 0; this.emissiveColor[1] = 0; this.emissiveColor[2] = 0;
       nDrawingObjects += 1;
       this.pickingColor = vec3.create();
       this.pickingColor[0] = (nDrawingObjects % 16777216) / 16777216;
       this.pickingColor[1] = (nDrawingObjects % 65536) / 65536;
       this.pickingColor[2] = (nDrawingObjects % 256)/256;
	}

    var drawingObjects = [];

    function initWorldObjects() {
												
        drawingObjects.push(new DrawingObject( neheTexture, cubeVertexPositionBuffer, cubeVertexColorBuffer, cubeVertexNormalBuffer, cubeVertexIndexBuffer, cubeVertexTextureCoordBuffer, 6.0, -5.0, -15.0, 0, 0, 0 )); 
        
        drawingObjects.push(new DrawingObject ( blueTexture, skydomeVertexPositionBuffer, null, skydomeVertexNormalBuffer, skydomeVertexIndexBuffer, skydomeVertexTextureCoordBuffer, 0.0, 0, 0, 0, 0, 0 ));
        
        var sun = new DrawingObject( whiteTexture, sunVertexPositionBuffer, null, sunVertexNormalBuffer, sunVertexIndexBuffer, sunVertexTextureCoordBuffer, 12.0, 8.0, 0.0, 0, 0, 0 );
        sun.emissiveColor[0] = 1.0; sun.emissiveColor[1] = 1.0; sun.emissiveColor[2] = 1.0;
        drawingObjects.push(sun); 

        var buffer = 1.0;
        for (x = 0; x < terrain.size; x++) {
            for (z = 0; z < terrain.size; z++) {
            //for (z = 0; z < 1; z++) {
              for (y = 0; y < 3; y++) {
                 if (Math.floor(terrain.map[z+(x*terrain.size)]%3) > y) {
                   drawingObjects.push(new DrawingObject( greenTexture, cubeVertexPositionBuffer, cubeVertexColorBuffer, cubeVertexNormalBuffer, cubeVertexIndexBuffer, cubeVertexTextureCoordBuffer, (x*(1+buffer))-10.0, (y*(1+buffer))-2.5, (z*(1+buffer))-10.0, 0, 0, 0 ));
                 } else if(y == 0 && Math.floor(terrain.map[z+(x*terrain.size)]%3) <= 0)
                 {
                   drawingObjects.push(new DrawingObject( blueTexture, cubeVertexPositionBuffer, cubeVertexColorBuffer, cubeVertexNormalBuffer, cubeVertexIndexBuffer, cubeVertexTextureCoordBuffer, (x*(1+buffer))-10.0, -2.5, (z*(1+buffer))-10.0, 0, 0, 0 ));  
                 }
              }
            }
        }

    }
    
    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    } 
    

  function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
      var elapsed = timeNow - lastTime;
        
      for (var i = 0, len = drawingObjects.length; i < len; i++) {
         // Relative Motion for Object #0           
         if (i == 0) {
            mat4.identity(rotm);
            mat4.rotate(rotm, drawingObjects[0].rx, [1, 0, 0]);
            mat4.rotate(rotm, drawingObjects[0].ry, [0, 1, 0]);
            mat4.rotate(rotm, drawingObjects[0].rz, [0, 0, 1]);
            mat4.toMat3(rotm, rm)
            adv[0] = rm[0] * drawingObjects[i].v[0] + rm[1] * drawingObjects[i].v[1] + rm[2] * drawingObjects[i].v[2];
            adv[1] = rm[3] * drawingObjects[i].v[0] + rm[4] * drawingObjects[i].v[1] + rm[5] * drawingObjects[i].v[2];
            adv[2] = rm[6] * drawingObjects[i].v[0] + rm[7] * drawingObjects[i].v[1] + rm[8] * drawingObjects[i].v[2];
         } else if (i == 2) { 
           // Billboard motion for Object #2 (star)
           // Rotate so that it is always facing the viewer
           mat4.rotate(mvMatrix, -drawingObjects[0].rx, [1.0, 0.0, 0.0]);  
           mat4.rotate(mvMatrix, -drawingObjects[0].ry, [0.0, 1.0, 0.0]);
           adv[0] = drawingObjects[i].v[0];
           adv[1] = drawingObjects[i].v[1];
           adv[2] = drawingObjects[i].v[2];
         } else {
             adv[0] = drawingObjects[i].v[0];
             adv[1] = drawingObjects[i].v[1];
             adv[2] = drawingObjects[i].v[2];
         }
          
          // Translation
         drawingObjects[i].x += (adv[0] * elapsed) / 1000.0;
         drawingObjects[i].y += (adv[1] * elapsed) / 1000.0;
         drawingObjects[i].z += (adv[2] * elapsed) / 1000.0;
        
         // Rotation
         drawingObjects[i].rx += (drawingObjects[i].w[0] * elapsed) / 1000.0;
         drawingObjects[i].ry += (drawingObjects[i].w[1] * elapsed) / 1000.0;
         drawingObjects[i].rz += (drawingObjects[i].w[2] * elapsed) / 1000.0;
      }
    }
    lastTime = timeNow;
  }   
    
   var currentlyPressedKeys = {};

  function handleKeyDown(event) {
    currentlyPressedKeys[event.keyCode] = true;

    if (currentlyPressedKeys[27]) {
       // Escape
       for (var i = 0, len = drawingObjects.length; i < len; i++) {
           drawingObjects[i].v[0] = 0;
           drawingObjects[i].v[1] = 0;
           drawingObjects[i].v[2] = 0;
           drawingObjects[i].w[0] = 0;
           drawingObjects[i].w[1] = 0;
           drawingObjects[i].w[2] = 0;
       }
       selectedObject = 0;
    }   
    if (currentlyPressedKeys[32]) {
       // Space
       drawingObjects.push(new DrawingObject( neheTexture, cubeVertexPositionBuffer, cubeVertexColorBuffer, cubeVertexNormalBuffer, cubeVertexIndexBuffer, cubeVertexTextureCoordBuffer, 3, 0, 0, 0, 0, 0 ));
       selectedObject = drawingObjects.length - 1; // select the newly created object
    }
    if (currentlyPressedKeys[79]) {
       // o
       if (selectedObject > 0) {
         selectedObject -= 1;
       } else {
         selectedObject = drawingObjects.length - 1
       }
        
    }
    if (currentlyPressedKeys[80]) {
       // p
       if (selectedObject >= drawingObjects.length - 1) {
          selectedObject = 0;
       } else {
          selectedObject += 1;
       }
    }
      
    //if (String.fromCharCode(event.keyCode) == "F") {
     // filter += 1;
     // if (filter == 3) {
     //   filter = 0;
     // }
    //}
  }

  function handleKeyUp(event) {
    currentlyPressedKeys[event.keyCode] = false;
  }   
    
  function handleGamepad()
  {
      if (controllers[0] != null) {
          drawingObjects[0].w[0] = controllers[0].axes[1];
          drawingObjects[0].w[1] = controllers[0].axes[0];
      }
  }
    
  function handleKeys() {
      // Key reference: https://css-tricks.com/snippets/javascript/javascript-keycodes/
    if (currentlyPressedKeys[8]) {
       // Backspace
    }
    if (currentlyPressedKeys[9]) {
       // Tab
    } 
    if (currentlyPressedKeys[13]) {
       // Enter
    }  
    if (currentlyPressedKeys[16]) {
       // Shift
    }   
    if (currentlyPressedKeys[17]) {
       // Ctrl
    }         
    if (currentlyPressedKeys[18]) {
       // Alt
    }
    if (currentlyPressedKeys[19]) {
       // Pause/Break
    }   
    if (currentlyPressedKeys[20]) {
       // Caps Lock
    }   
    if (currentlyPressedKeys[27]) {
       // Escape
    }   
    if (currentlyPressedKeys[32]) {
       // Space
    }   
    if (currentlyPressedKeys[33]) {
      // Page Up
      //z -= 0.05;
    }
    if (currentlyPressedKeys[34]) {
      // Page Down
      //z += 0.05;
    }
    if (currentlyPressedKeys[35]) {
       // End
    }    
    if (currentlyPressedKeys[36]) {
       // Home
    }         
    if (currentlyPressedKeys[37]) {
      // Left cursor key
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[0] -= 0.1;
      } else {
         drawingObjects[selectedObject].w[1] -= 0.01;
      }
    }
    if (currentlyPressedKeys[38]) {
      // Up cursor key
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[1] -= 0.1;
      } else {
         drawingObjects[selectedObject].w[0] -= 0.01;
      }
    }      
    if (currentlyPressedKeys[39]) {
      // Right cursor key
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[0] += 0.1;
      } else {
         drawingObjects[selectedObject].w[1] += 0.01;
      }
    }
    if (currentlyPressedKeys[40]) {
      // Down cursor key
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[1] += 0.1;
      } else {
         drawingObjects[selectedObject].w[0] += 0.01;
      }
    }
    if (currentlyPressedKeys[45]) {
       // Insert
    }
    if (currentlyPressedKeys[46]) {
       // Insert
    }
    if (currentlyPressedKeys[48]) {
       // 0
    }
    if (currentlyPressedKeys[49]) {
       // 1
    }
    if (currentlyPressedKeys[50]) {
       // 2
    }
    if (currentlyPressedKeys[51]) {
       // 3
    }
    if (currentlyPressedKeys[52]) {
       // 4
    }
    if (currentlyPressedKeys[53]) {
       // 5
    }
    if (currentlyPressedKeys[54]) {
       // 6
    }
    if (currentlyPressedKeys[55]) {
       // 7
    }
    if (currentlyPressedKeys[56]) {
       // 8
    }
    if (currentlyPressedKeys[57]) {
       // 9
    }
    if (currentlyPressedKeys[65]) {
       // a
        lightDirectionX += 0.1;
    }
    if (currentlyPressedKeys[66]) {
       // b
        if (currentlyPressedKeys[16] && currentlyPressedKeys[18]) {
            // ALT + SHIFT
            ambientB -= 0.1;
        } else if (currentlyPressedKeys[18]) {
            // ALT NO SHIFT
            ambientB += 0.1;
        } else if (currentlyPressedKeys[16]) {
            // SHIFT
            directionalB -= 0.1;
        } else {
            // NO SHIFT
            directionalB += 0.1;
        }
    }
    if (currentlyPressedKeys[67]) {
       // c
    }
    if (currentlyPressedKeys[68]) {
       // d
        lightDirectionX -= 0.1;
    }
    if (currentlyPressedKeys[69]) {
       // e
    }
     if (currentlyPressedKeys[70]) {
       // f
    }
    if (currentlyPressedKeys[71]) {
       // g
        if (currentlyPressedKeys[16] && currentlyPressedKeys[18]) {
            // ALT + SHIFT
            ambientG -= 0.1;
        } else if (currentlyPressedKeys[18]) {
            // ALT NO SHIFT
            ambientG += 0.1;
        } else if (currentlyPressedKeys[16]) {
            // SHIFT
            directionalG -= 0.1;
        } else {
            // NO SHIFT
            directionalG += 0.1;
        }
    }
    if (currentlyPressedKeys[72]) {
       // h
    }
    if (currentlyPressedKeys[73]) {
       // i
    }
    if (currentlyPressedKeys[74]) {
       // j
    }
    if (currentlyPressedKeys[75]) {
       // k
    }
    if (currentlyPressedKeys[76]) {
       // l
    }
    if (currentlyPressedKeys[77]) {
       // m
    }
    if (currentlyPressedKeys[78]) {
       // n
    }
    if (currentlyPressedKeys[79]) {
       // o
    }
    if (currentlyPressedKeys[80]) {
       // p
    }
    if (currentlyPressedKeys[81]) {
       // q
    }
    if (currentlyPressedKeys[82]) {
       // r
        if (currentlyPressedKeys[16] && currentlyPressedKeys[18]) {
            // ALT + SHIFT
            ambientR -= 0.1;
        } else if (currentlyPressedKeys[18]) {
            // ALT NO SHIFT
            ambientR += 0.1;
        } else if (currentlyPressedKeys[16]) {
            // SHIFT
            directionalR -= 0.1;
        } else {
            // NO SHIFT
            directionalR += 0.1;
        }
    }
    if (currentlyPressedKeys[83]) {
       // s
    }
    if (currentlyPressedKeys[84]) {
       // t
    }
    if (currentlyPressedKeys[85]) {
       // u
    }
    if (currentlyPressedKeys[86]) {
       // v
    }
    if (currentlyPressedKeys[87]) {
       // w
        lightDirectionY -= 0.1;
    }
    if (currentlyPressedKeys[88]) {
       // x
       lightDirectionY += 0.1;
    }
    if (currentlyPressedKeys[89]) {
       // y
    }
    if (currentlyPressedKeys[90]) {
       // z
    }
    if (currentlyPressedKeys[91]) {
       // Left Window Key
    }
    if (currentlyPressedKeys[92]) {
       // Right Window Key
    }
    if (currentlyPressedKeys[93]) {
       // Select Key
    }
    if (currentlyPressedKeys[96]) {
       // Numpad 0
    }
    if (currentlyPressedKeys[97]) {
       // Numpad 1
    }
    if (currentlyPressedKeys[98]) {
       // Numpad 2
    }
    if (currentlyPressedKeys[99]) {
       // Numpad 3
    }
    if (currentlyPressedKeys[100]) {
       // Numpad 4
    }
    if (currentlyPressedKeys[101]) {
       // Numpad 5
    }
    if (currentlyPressedKeys[102]) {
       // Numpad 6
    }
    if (currentlyPressedKeys[103]) {
       // Numpad 7
    }
    if (currentlyPressedKeys[104]) {
       // Numpad 8
    }
    if (currentlyPressedKeys[105]) {
       // Numpad 9
    }
    if (currentlyPressedKeys[106]) {
       // Multiply
    }
    if (currentlyPressedKeys[107]) {
       // Add
    }
    if (currentlyPressedKeys[109]) {
       // Subtract
    }
    if (currentlyPressedKeys[110]) {
       // Decimal Point
    }
    if (currentlyPressedKeys[111]) {
       // Divide
    }
    if (currentlyPressedKeys[112]) {
       // F1
    }
    if (currentlyPressedKeys[113]) {
       // F2
    }
    if (currentlyPressedKeys[114]) {
       // F3
    }
    if (currentlyPressedKeys[115]) {
       // F4
    }
    if (currentlyPressedKeys[116]) {
       // F5
    }
    if (currentlyPressedKeys[117]) {
       // F6
    }
    if (currentlyPressedKeys[118]) {
       // F7
    }
    if (currentlyPressedKeys[119]) {
       // F8
    }
    if (currentlyPressedKeys[120]) {
       // F9
    }
    if (currentlyPressedKeys[121]) {
       // F10
    }
    if (currentlyPressedKeys[122]) {
       // F11
    }
    if (currentlyPressedKeys[123]) {
       // F12
    }
    if (currentlyPressedKeys[144]) {
       // Num Lock
    }
    if (currentlyPressedKeys[145]) {
       // Scroll Lock
    }
    if (currentlyPressedKeys[186]) {
       // Semi-Colon
    }
    if (currentlyPressedKeys[187]) {
       // Equals Sign
    }
    if (currentlyPressedKeys[188]) {
       // Comma
    }
    if (currentlyPressedKeys[189]) {
       // Dash
    }
    if (currentlyPressedKeys[190]) {
       // Period
    }
    if (currentlyPressedKeys[191]) {
       // Forward Slash
    }
    if (currentlyPressedKeys[192]) {
       // Grave Accent
    }
    if (currentlyPressedKeys[219]) {
       // Open Bracket
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[2] -= 0.1;
      } else {
         drawingObjects[selectedObject].w[2] -= 0.01;
      } 
    }
    if (currentlyPressedKeys[220]) {
       // Back Slash
    }
    if (currentlyPressedKeys[221]) {
       // Close Bracket
      if (currentlyPressedKeys[16]) {
         drawingObjects[selectedObject].v[2] += 0.1;
      } else {
         drawingObjects[selectedObject].w[2] += 0.01;
      } 
    }
    if (currentlyPressedKeys[222]) {
       // Single Quote
    }
  }
    
    
  var mouseDown = false;
  var lastMouseX = null;
  var lastMouseY = null;
    
  function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = canvas.height - event.clientY;
  }

  function handleMouseUp(event) {
    mouseDown = false;
  }

  function handleMouseMove(event) {
    if (!mouseDown) {
      return;
    }
    var newX = event.clientX;
    var newY = canvas.height - event.clientY;

    var deltaX = newX - lastMouseX;

    lastMouseX = newX
    lastMouseY = newY;
  }
    
var gamepads = {};

function gamepadHandler(event, connecting) {
  var gamepad = event.gamepad;
  // Note:
  // gamepad === navigator.getGamepads()[gamepad.index]

  if (connecting) {
    gamepads[gamepad.index] = gamepad;
  } else {
    delete gamepads[gamepad.index];
  }
}
    
    function drawPickingScene()
    {
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

        var previousProgram = currentProgram
        currentProgram = pickingProgram;
        gl.useProgram(currentProgram);
        
        mat4.identity(mvMatrix);

        // Camera (Perspective) - Attached to Object # 0
        mat4.rotate(mvMatrix, drawingObjects[0].rx, [1, 0, 0]);
        mat4.rotate(mvMatrix, drawingObjects[0].ry, [0, 1, 0]);
        mat4.rotate(mvMatrix, drawingObjects[0].rz, [0, 0, 1]);
        mat4.translate(mvMatrix, [drawingObjects[0].x, drawingObjects[0].y, drawingObjects[0].z]);

        // Don't draw object #0 (the camera)
        for (var i = 1, len = drawingObjects.length; i < len; i++) {
           mvPushMatrix();
            
           mat4.translate(mvMatrix, [drawingObjects[i].x, drawingObjects[i].y, drawingObjects[i].z]);
            
           mvPushMatrix();
            
           mat4.rotate(mvMatrix, drawingObjects[i].rx, [1,0,0]);
           mat4.rotate(mvMatrix, drawingObjects[i].ry, [0,1,0]);
           mat4.rotate(mvMatrix, drawingObjects[i].rz, [0,0,1]);
               
		   setMatrixUniforms();
            
           gl.uniform4f(
                currentProgram.pickingColorUniform,
                drawingObjects[i].pickingColor[0],
                drawingObjects[i].pickingColor[1],
                drawingObjects[i].pickingColor[2],
                1.0
            );
          gl.bindBuffer(gl.ARRAY_BUFFER, drawingObjects[i].vertexPositionBuffer);
          gl.vertexAttribPointer(currentProgram.vertexPositionAttribute, drawingObjects[i].vertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, drawingObjects[i].vertexIndexBuffer);
        setMatrixUniforms();
          gl.drawElements(gl.TRIANGLES, drawingObjects[i].vertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0); 
		   
           mvPopMatrix();
           mvPopMatrix();
		}
        

        gl.uniform1i(currentProgram.samplerUniform, 0);
        
        currentProgram = previousProgram;
        gl.useProgram(currentProgram);
    }
    
    function doPicking()
    {
      gl.bindFramebuffer(gl.FRAMEBUFFER, rttFramebuffer);
      drawPickingScene();
      var colorPicked = new Uint8Array(4);
      gl.readPixels(lastMouseX, lastMouseY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, colorPicked);
      for (i = 0; i < drawingObjects.length; i++)
      {
          if (colorPicked[0] == Math.floor(drawingObjects[i].pickingColor[0] * 256) &&
              colorPicked[1] == Math.floor(drawingObjects[i].pickingColor[1] * 256) &&
              colorPicked[2] == Math.floor(drawingObjects[i].pickingColor[2] * 256) )
          {
              selectedObject = i;
              break;
          }
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      document.getElementById("mousestat").innerHTML = lastMouseX + " " + lastMouseY + " " + colorPicked + " selected = " + selectedObject;
    }
    
    function tick() {
        requestAnimFrame(tick);
        handleKeys();
        handleGamepad();
        if(mouseDown) doPicking();
        drawScene();
        //drawPickingScene();
        animate();
    }

    var nDrawingObjects = 0;
    var lastTime = 0;
    var lighting = true;
    var pointLighting = true;
    var perFragmentLighting = true;
    var textures = true;
    var ambientR = 0.2;
    var ambientG = 0.2;
    var ambientB = 0.2;
    var lightDirectionX = -0.25;
    var lightDirectionY = -0.25;
    var lightDirectionZ = -1.0;    
    var directionalR = 0.8;
    var directionalG = 0.8;
    var directionalB = 0.8;
    var pointR = 0.8;
    var pointG = 0.8;
    var pointB = 0.8;
    
    var selectedObject = 0;
    var rx = 0
    var ry = 0;
    var rz = 0;
    var x = 0;
    var y = 0;
    var z = 0;
    var adv = vec3.create();
    var rotm = mat4.create();
    var rm = mat3.create();
    var terrain = new Terrain(4);
    var canvas;
    function webGLStart() {
        canvas = document.getElementById("canvas");
        initGL(canvas);
        //initTextureFramebuffer();
        initShaders();
        initBuffers();
        initTexture();
        terrain.generate(0.7);
        loadWorld();
        initWorldObjects();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);

        document.onkeydown = handleKeyDown;
        document.onkeyup = handleKeyUp;       
        canvas.onmousedown = handleMouseDown;
        document.onmouseup = handleMouseUp;
        document.onmousemove = handleMouseMove;
        
        
        drawScene();
        tick();
    }

    
var haveEvents = 'GamepadEvent' in window;
var controllers = {};
var rAF = window.mozRequestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.requestAnimationFrame;

function connecthandler(e) {
  addgamepad(e.gamepad);
}
function addgamepad(gamepad) {
  controllers[gamepad.index] = gamepad; var d = document.createElement("div");
  d.setAttribute("id", "controller" + gamepad.index);
  var t = document.createElement("h1");
  t.appendChild(document.createTextNode("gamepad: " + gamepad.id));
  d.appendChild(t);
  var b = document.createElement("div");
  b.className = "buttons";
  for (var i=0; i<gamepad.buttons.length; i++) {
    var e = document.createElement("span");
    e.className = "button";
    //e.id = "b" + i;
    e.innerHTML = i;
    b.appendChild(e);
  }
  d.appendChild(b);
  var a = document.createElement("div");
  a.className = "axes";
  for (i=0; i<gamepad.axes.length; i++) {
    e = document.createElement("progress");
    e.className = "axis";
    //e.id = "a" + i;
    e.setAttribute("max", "2");
    e.setAttribute("value", "1");
    e.innerHTML = i;
    a.appendChild(e);
  }
  d.appendChild(a);
  document.getElementById("start").style.display = "none";
  document.body.appendChild(d);
  rAF(updateStatus);
}

function disconnecthandler(e) {
  removegamepad(e.gamepad);
}

function removegamepad(gamepad) {
  var d = document.getElementById("controller" + gamepad.index);
  document.body.removeChild(d);
  delete controllers[gamepad.index];
}

function updateStatus() {
  scangamepads();
  for (j in controllers) {
    var controller = controllers[j];
    var d = document.getElementById("controller" + j);
    var buttons = d.getElementsByClassName("button");
    for (var i=0; i<controller.buttons.length; i++) {
      var b = buttons[i];
      var val = controller.buttons[i];
      var pressed = val == 1.0;
      if (typeof(val) == "object") {
        pressed = val.pressed;
        val = val.value;
      }
      var pct = Math.round(val * 100) + "%";
      b.style.backgroundSize = pct + " " + pct;
      if (pressed) {
        b.className = "button pressed";
      } else {
        b.className = "button";
      }
    }

    var axes = d.getElementsByClassName("axis");
    for (var i=0; i<controller.axes.length; i++) {
      var a = axes[i];
      a.innerHTML = i + ": " + controller.axes[i].toFixed(4);
      a.setAttribute("value", controller.axes[i] + 1);
    }
  }
  rAF(updateStatus);
}

function scangamepads() {
  var gamepads = navigator.getGamepads ? navigator.getGamepads() : (navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : []);
  for (var i = 0; i < gamepads.length; i++) {
    if (gamepads[i]) {
      if (!(gamepads[i].index in controllers)) {
        addgamepad(gamepads[i]);
      } else {
        controllers[gamepads[i].index] = gamepads[i];
      }
    }
  }
}

if (haveEvents) {
  window.addEventListener("gamepadconnected", connecthandler);
  window.addEventListener("gamepaddisconnected", disconnecthandler);
} else {
  setInterval(scangamepads, 500);
} 

</script>


</head>


<body onload="webGLStart();">

    <canvas id="canvas" style="border: none;" width="1000" height="500"></canvas>
    <h2 id="mousestat">Blah</h2>
    <h2 id="start">Press a button on your controller to start</h2>

    <br/>
</body>

</html>
